<!DOCTYPE html>
<html>
<head>
    <title>Godel's Gauntlet</title>
    <style>
        body { position: relative; }
        a { position: absolute; top: 10px; left: 10px; z-index: 2; }
        canvas { position: absolute; top: 0; left: 0; z-index: 1; }
    </style>
</head>
<body>
    <a href="https://github.com/thetechnocrat-dev/thetechnocrat-dev.github.io/blob/main/index.html#L158" target="_blank">
      <img src="github-logo.png" alt="GitHub Logo" width="24" height="24">
      <span>This game is open source</span>
    </a>
    <canvas id="gameCanvas"></canvas>
    <script>
        var canvas = document.getElementById('gameCanvas');
        var ctx = canvas.getContext('2d');

        // Set canvas size to fill the window
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Player and goal objects
        var player = { 
            x: canvas.width / 2, 
            y: 50,
            radius: 20, 
            vx: 0, 
            vy: 0, 
            speed: 0.1, 
            maxSpeed: 3
        };
        var goal = { 
            x: canvas.width / 2, 
            y: canvas.height / 2, 
            radius: 42, 
            angle1: 0, 
            angle2: 0, 
            angle3: 0 
        };

        // Listen for click events
        canvas.addEventListener('click', function(e) {
            if (!player.freeze) {
                var rect = canvas.getBoundingClientRect();
                var clickX = e.clientX - rect.left;
                var clickY = e.clientY - rect.top;

                // Set the player's target
                player.target = { x: clickX, y: clickY };
            }
        });

        // Main game loop
        function gameLoop() {
            // Move towards target if it exists
            if (player.target) {
                var dx = player.target.x - player.x;
                var dy = player.target.y - player.y;
                var distance = Math.sqrt(dx * dx + dy * dy);

                if(distance > 1) {
                    // Apply velocity to player position
                    player.vx = dx / distance * player.speed;
                    player.vy = dy / distance * player.speed;
                    player.x += player.vx;
                    player.y += player.vy;

                    // Accelerate
                    player.speed += 0.1;
                    if(player.speed > player.maxSpeed) {
                        player.speed = player.maxSpeed;
                    }
                } else {
                    // Decelerate
                    player.speed -= 0.1;
                    if(player.speed < 0) {
                        player.speed = 0;
                    }
                }
            }

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Create and store the path for the outer rotating circle
            var outerCirclePath = new Path2D();
            goal.angle1 += 0.01;
            var startAngleOuter = goal.angle1;
            var endAngleOuter = startAngleOuter + Math.PI * 2 - player.radius * 3 / goal.radius;
            var outerCircleRadius = goal.radius * 1.618 ** 3
            outerCirclePath.arc(goal.x, goal.y, outerCircleRadius, startAngleOuter, endAngleOuter);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 5;
            ctx.stroke(outerCirclePath);

            // Create and store the path for the middle rotating circle
            var middleCirclePath = new Path2D();
            goal.angle2 -= 0.01;
            var startAngleMiddle = goal.angle2;
            var endAngleMiddle = startAngleMiddle + Math.PI * 2 - player.radius * 3 / goal.radius;
            var middleCircleRadius = goal.radius * 1.618 ** 2
            middleCirclePath.arc(goal.x, goal.y, middleCircleRadius, startAngleMiddle, endAngleMiddle);
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 5;
            ctx.stroke(middleCirclePath);

            // Create and store the path for the inner rotating circle
            var innerCirclePath = new Path2D();
            goal.angle3 = Math.atan2(player.y - goal.y, player.x - goal.x) + Math.PI;
            var startAngleInner = goal.angle3;
            var endAngleInner = startAngleInner + Math.PI * 2 - player.radius * 3 / goal.radius;
            var innerCircleRadius = goal.radius * 1.618
            innerCirclePath.arc(goal.x, goal.y, innerCircleRadius, startAngleInner, endAngleInner);
            ctx.strokeStyle = 'purple';
            ctx.lineWidth = 5;
            ctx.stroke(innerCirclePath);

            var playerPath = new Path2D();
            playerPath.arc(player.x, player.y, player.radius, 0, Math.PI * 2);

            // Create and store the paths for the outer rotating circle
            var outerCirclePathOuter = new Path2D();
            var outerCirclePathInner = new Path2D();
            // modify radius for outer and inner invisible barriers
            outerCirclePathOuter.arc(goal.x, goal.y, outerCircleRadius + player.radius, startAngleOuter, endAngleOuter);
            outerCirclePathInner.arc(goal.x, goal.y, outerCircleRadius - player.radius, startAngleOuter, endAngleOuter);

            // Create and store the paths for the middle rotating circle
            var middleCirclePathOuter = new Path2D();
            var middleCirclePathInner = new Path2D();
            // modify radius for outer and inner invisible barriers
            middleCirclePathOuter.arc(goal.x, goal.y, middleCircleRadius + player.radius, startAngleMiddle, endAngleMiddle);
            middleCirclePathInner.arc(goal.x, goal.y, middleCircleRadius - player.radius, startAngleMiddle, endAngleMiddle);

            // Create and store the paths for the inner rotating circle
            var innerCirclePathOuter = new Path2D();
            var innerCirclePathInner = new Path2D();
            // modify radius for outer and inner invisible barriers
            innerCirclePathOuter.arc(goal.x, goal.y, innerCircleRadius + player.radius, startAngleInner, endAngleInner);
            innerCirclePathInner.arc(goal.x, goal.y, innerCircleRadius - player.radius, startAngleInner, endAngleInner);

            // Reset and freeze the player
            if (player.freeze) {
               ctx.globalAlpha = 0.5;
            } else {
                ctx.globalAlpha = 1;
            }

            // Check for collision with the rotating circles
            if (!player.freeze &&
                (ctx.isPointInStroke(outerCirclePathOuter, player.x, player.y) ||
                 ctx.isPointInStroke(outerCirclePathInner, player.x, player.y) ||
                 ctx.isPointInStroke(middleCirclePathOuter, player.x, player.y) ||
                 ctx.isPointInStroke(middleCirclePathInner, player.x, player.y) ||
                 ctx.isPointInStroke(innerCirclePathOuter, player.x, player.y) ||
                 ctx.isPointInStroke(innerCirclePathInner, player.x, player.y))) {
                player.target = {};
                player.reset = true; 
                player.freeze = true;
                setTimeout(function() {
                    // Perform the desired change to the variable
                    console.log('done freeze')
                    player.freeze = false;
                    player.x = canvas.width / 2;
                    player.y = 50;
                    player.vx = 0;
                    player.vy = 0;
                }, 1000);
            }


            // Draw the player
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'blue';
            ctx.fill();

            // Draw the goal
            ctx.beginPath();
            ctx.arc(goal.x, goal.y, goal.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'green';
            ctx.fill();

            // Request next animation frame
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
